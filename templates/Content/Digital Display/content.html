{% extends "blogpage.html" %}

{% block pageTitle %}
How to Build Your Own Digital Display
{% endblock %}

{% block date %}
{{ data["date"] }}
{% endblock %}

{% block content %}

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

<div style="display:flex; padding-left: 15px; padding-right: 15px;">
    <div class="flex-1 border_right" style="padding-right: 10px;">
        <img src="{{data['path'] +  'images/thumbnail.jpeg'}}" style="width:200px; padding-top:40px">
    </div>
    <div class="flex-3" style="padding-left:10px">
        <div style=>
            <div class="heading">
                Introduction
            </div>
        </div>
        <div class="paragraph">
            What's a better way to use a 2.4" TFT display, an Arduino Mega 2560, a DS3231 RTC and a buzzer than
            making a digital display to show the time and temperature, and also function as an alarm clock? If
            you want to know how to do exactly that, stick around!
        </div>
        <div class="paragraph">
            As you can see from the picture, the module is shaped in such a seats snugly into the Mega, allowing it
            to be interfaced with relative ease. I connected the RTC to the Arduino pins 18-21 for GND, VCC, SDA and SCL
            respectively. For the alarm, I used the pins 49 and a GND pin to connect a buzzer.
        </div>
    </div>
</div>

<div class="headingPadding">
    <div class="heading">
        Instructions
    </div>
</div>
<div class="paragraph">
    <p>First, go over to your Arduino IDE, and install the following libraries:</p>

    <p>
        <li>SdFat library by Bill Greiman (version 1.0.1). Then edit the src/SdFatConfig.h file and change the line #define ENABLE_SOFTWARE_SPI_CLASS from 0 to 1.</li>
        <li>AdaFruit GFX library along with all its dependencies</li>
        <li>MCUFriend GFX library</li>
        <li>AdaFruit TouchScreen Library with all its dependencies</li>
    </p>
    <p>Next, head over to <a href="https://github.com/DethCubeHax/Arduino_Smart_Display">my Github</a> and grab a copy of
    my implementation, and open it in Arduino IDE. Copy over the images to the root of an SD card, and create a folder
    called templogs to allow the arduino to store temperature logs.</p>

    <p>Finally, flash the code to your Due, connect the display, RTC and buzzer, and enjoy!</p>
</div>

<div class="headingPadding">
    <div class="heading">
        Code Breakdown
    </div>
</div>
<div class="headingPadding">
    <div class="heading2">
        The setup function
    </div>
</div>
<div class="paragraph">So the first step is to initialize the pins of the arduino. 
    First, I set the states of pins GND and VCC as OUTPUTs, and set them LOW and HIGH respectively. 
    While this may be potentially harmful for the arduino, considering the RTC uses very low power, I decided it was worth to avoid the inconvenience of extra wires. 
    Next, I set the pinMode of the buzzer pin 49 as an OUTPUT. 
    Finally, I initialize the TFT display and set it to a horizontal rotation, and check that the SD card is inserted and readable,
    and send an error output via the Serial interface on baud rate 9600 for debugging. 
    Finally the dissplay() function is called to initialize the display on startup.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">void setup() {
                // Comms
                // Initiate serial communication with 9600 baud rate
                Serial.begin(9600);
                // Initiate SPI with the DS3231   
                Wire.begin();         
              
                // DS3231
                //Setting the pin modes for the defined pins
                pinMode(vcc, OUTPUT);   
                pinMode(gnd, OUTPUT);
              
                // Power
                // Provide power to the DS3231 without messy wiring
                digitalWrite(vcc, HIGH);    
                digitalWrite(gnd, LOW);
              
                // Alarm buzzer
                pinMode(buzzer, OUTPUT);
                // TFT
                // Read the TFT's ID and start it
                uint16_t ID = tft.readID();   
                tft.begin(ID);
                // Set up TFT in horizontal layout
                tft.setRotation(1);           
              
                bool good = SD.begin(SD_CS);
                  if (!good) {
                      Serial.print(F("cannot start SD"));
                      while (1);
                  }
                dissplay();
              }
                  </pre>
          </div>
        </div>
    </div>
</div>


<div class="headingPadding">
    <div class="heading2">
        The Loop Function
    </div>
</div>
<div class="paragraph">
    Now we move on to the loop function, which repeatedly calls over functions to update the contents 
    of the display, and constantly checks for any touch input from the user. 
    I decided to go ahead with a two menu layout; one that displays the clock and temperature,
    and another that displays options for the user to choose from, depending on the value of the 
    “Options” variable. Now let’s break down how exactly this is done. 
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">void loop() {
                // Check the touch position
                bool down = Touch_getXY();              
                if (Options == 0){
                  // Repeatedly update the time
                  getTime();                              
                  
                  // Render the display ONLY when the
                  if (prevMin != Minute){                 
                    dissplay();
                    
                    // Arduino has started and refresh it per minute                           
                    views = 1;
                  }                                       
                  prevMin = Minute;    
                  
                  // Repeatedly update the temperature
                  tempUpdate();  
                  
                  // Bring up the buttons on first run or when switching menus
                  initOptions();                          
                  
                  // Send coordinates to Adafruit GFX library's button handler
                  option_btn.press(down && option_btn.contains(pixel_x, pixel_y));    
              
                  // Check if the options button is pressed
                  if (option_btn.justPressed()){          
                    option_btn.drawButton(true);
                  }
                  
                  if (option_btn.justReleased()){
                    // If aforementioned button is pressed, clear the screen 
                    option_btn.drawButton();
                    // by drawing over it to render the options menu
                    Options = 1;
                    ButtonsInit = 0;
                    nm = "sunset.bmp"; x = 0; y = 0;
                    showBMP();
                    options();
                  }
                  
                  // Check if alarms is enabled
                  if (alarms == 1){ 
                      // Iterate over the Alarms array to read the alarm times                      
                     for (int x = 0; x < 5; x ++){
                      if ((Alarms[x] - 1 == (Hour * 100 + Minute)) && engaged == 0){
                        // Engage the buzzer one minute before the alarm
                        ring = 1;                         
                        initOptions();
                        engaged = 1;
                      }
                      if (Options == 0 && ring == 0){
                       tft.setCursor(160, 175);
                       tft.setTextSize(2);
                       tft.setTextColor(WHITE, CRIMSON);
                       tft.println("No Upcoming");
                       tft.setCursor(170, 195);
                       tft.print("Alarms");
                      }
                      // Play beep-beep when the alarm time matches the current time
                      if (Alarms[x] == (Hour * 100 + Minute) && ring == 1){   
                        if ((Second % 2) == 0){
                          digitalWrite(buzzer, HIGH);
                        }
                        else{
                          digitalWrite(buzzer, LOW);
                        }
                      }
                      
                      // Request touch coordinates
                      down = Touch_getXY();               
                      // Send coordinates to Adafruit GFX library's button handler
                      alarm_stop.press(down && alarm_stop.contains(pixel_x, pixel_y));
                      if (alarm_stop.justPressed()){
                        alarm_btn.drawButton(true);
                      }
                      if (alarm_stop.justReleased()){
                        alarm_btn.drawButton();
                        ring = 0;
                        ButtonsInit = 0;
                        digitalWrite(buzzer, LOW);
                        int engaged = 0;
                        nm = "sunset.bmp"; x = 0; y = 0;
                        showBMP();
                        
                        dissplay();
                        
                      }
                    }  
                  }
                  if(Options == 0 && alarms == 0){
                       tft.setCursor(160, 175);
                       tft.setTextSize(2);
                       tft.setTextColor(WHITE, CRIMSON);
                       tft.println("Alarms");
                       tft.setCursor(160, 195);
                       tft.print("Disabled");
                  }
                }
              
                  </pre>

          </div>
        </div>
    </div>
</div>

<div class="paragraph">
    To get the touch coordinates we use the Touch_getXY() function to obtain the current coordinates 
    of any touch input by the user, and store it in a variable called down. Then it checks if the 
    value of “Options” is 0 or 1, if it’s the former, the clock and temperature are displayed, 
    otherwise a menu of options is presented instead. Let’s consider the default clock layout first.
    The Mega calls the getTime() function to obtain the latest time, and then checks if the time
    has changed, and only refresh the display if that is the case. Then we call upon the 
    tempUpdate() function which gets the most recent value of the temprature. Next, we call the 
    initOptions() function to bring up the buttons for the current display and render them. 
    Now for checking whether or not the “Options” button is pressed by passing it into the option 
    button class’s press function, which changes the value of Options to 1, switching the view to 
    the options layout instead. The “alarms” variable serves to activate the alarm; if it is 1, 
    and the current time is precisely 1 minute earlier than the alarm time, the “ring” variable 
    is set to 1 and the initOptions() function is called to render the button to allow the user 
    stop the alarm. As the current time becomes equal to the alarm time, the buzzer is beeped 
    repeatedly to alert the user, and if the stop button is pressed while the buzzer sounds, 
    the touch data is once again sent to the button class’s press() function to determine its 
    state, stopping the alarm if it is pressed. If there are no alarms in the near future, 
    the user is alerted accordingly by a message on the screen.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
                <pre class="prettyprint C" style="border:none">else{
                    options();
                    initOptions();
                    alarm_btn.press(down && alarm_btn.contains(pixel_x, pixel_y));
                    alarm_off_btn.press(down && alarm_off_btn.contains(pixel_x, pixel_y));
                    International.press(down && International.contains(pixel_x, pixel_y));
                    Imperial.press(down && Imperial.contains(pixel_x, pixel_y));
                    log_on.press(down && log_on.contains(pixel_x, pixel_y));
                    log_off.press(down && log_off.contains(pixel_x, pixel_y));
                    close_btn.press(down && close_btn.contains(pixel_x, pixel_y));
                
                    if (alarm_btn.justPressed()){
                      alarm_btn.drawButton(true);
                    }
                    if (alarm_off_btn.justPressed()){
                      alarm_off_btn.drawButton(true);
                    }
                    if (close_btn.justPressed()){
                      close_btn.drawButton(true);
                      Serial.println("Exit button pressed");
                    }
                    if (International.justPressed()){
                      International.drawButton(true);
                    }
                    if (Imperial.justPressed()){
                      Imperial.drawButton(true);
                    }
                    if (log_on.justPressed()){
                      log_on.drawButton(true);
                    }
                    if (log_off.justPressed()){
                      log_off.drawButton(true);
                    }
                    
                    if (alarm_btn.justReleased()){
                      alarm_btn.drawButton();
                      alarms = 1;
                    }
                    if (alarm_off_btn.justReleased()){
                      alarm_off_btn.drawButton();
                      alarms = 0;
                    }
                    if (International.justReleased()){
                      International.drawButton();
                      TimeMode = "INTL";
                    }
                    if (Imperial.justReleased()){
                      Imperial.drawButton();
                      TimeMode = "IMPL";
                    }
                    if (log_on.justReleased()){
                      log_on.drawButton();
                      Log = 1;
                    }
                    if (log_off.justReleased()){
                      log_off.drawButton();
                      Log = 0;
                    }
                    
                    if (close_btn.justReleased()){
                      close_btn.drawButton();
                      Serial.println("Exit button pressed");
                      Options = 0;
                      ButtonsInit = 0;
                      nm = "sunset.bmp";
                      x = 0; y = 0;
                      showBMP();
                      nm = "temperat.bmp"; x = 240; y = 10;
                      showBMP();
                      dissplay();
                    }
                  }
                }
            </pre>

          </div>
        </div>
    </div>
</div>

<div class="paragraph">
    If the value of Options is 1, however, the options() and initOptions() functions are called to 
    render the layout and buttons, presenting the user with options to enable or disable the alarm, 
    change between International and Imperial time formats and/or enable or disable temperature 
    logging. Just like the buttons discussed prior, the touch coordinates are sent to the button 
    classes’ press() functions to check if it has been pressed, and the Arduino changes the variables 
    accordingly to activate or deactivate the various features.
</div>

<div class="headingPadding">
    <div class="heading2">
        The GetTime Function
    </div>
</div>
<div class="paragraph">
    The getTime() function is used to get the time data from the RTC via the I2C interface. 
    Now there are some libraries that exist to make accessing this easy, however, given that I 
    didn't need all of the RTC's features, I decided to access the data in a more granular fashion. 
    So here's the bit of code to do exactly that.
</div>
<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">void getTime(){
                Wire.beginTransmission(DS3231_ADDRESS);    // Start the transmission at 0x68
                Wire.write(0);                             // Signal the RTC to provide time
                Wire.endTransmission();                    // End the transmission

                Wire.requestFrom(DS3231_ADDRESS, 7);

                Second = bcdToDec(Wire.read());    // Receive the seconds

                Minute = bcdToDec(Wire.read());    // Receive the minute

                Hour = bcdToDec(Wire.read());      // Receive the hour

                DoW = bcdToDec(Wire.read());       // Receive the day of week

                Date = bcdToDec(Wire.read());      // Receive the date of month

                Month = bcdToDec(Wire.read());     // Receive the month

                Year = bcdToDec(Wire.read());      // Receive the year

                Wire.beginTransmission(DS3231_ADDRESS);   // Request RTC to send temperature
                Wire.write(DS3231_TEMP);
                Wire.endTransmission();
                Wire.requestFrom(DS3231_ADDRESS, 1);

                temp = bcdToDec(Wire.read());   // Receive the temperature
            }</pre>

          </div>
        </div>
    </div>
</div>
    
<div class="paragraph">
    First, we need to get the current date and time. We first start the I2C transfer by sending a value of 0x68, stored as a variable called DS3231_ADDRESS using the 
    Wire.beginTransmission() function, followed by a value of 0 and ending the transmission.
    This tells the RTC to return the current value of time at the point when the request has been made, which
    Subsequently, the values returned by the RTC are read in sequence by wire.Read(), which we store in appropriate variables
    for displaying onto the screen. In addition, we send a value of 0x11 stored as DS3231_TEMP, which tells the RTC to return
    the current temperature, which is also read by Wire.read(). The values, however, aren't directly readable since they are returned by the RTC 
    as BCD values, so they need to be converted to decimal, which I implemented in the bcdToDec() function.
</div>

<div class="headingPadding">
    <div class="heading2">
        The Display Function
    </div>
</div>
<div class="paragraph">
    The dissplay() function exists to display the default layout when the Options variable is 0.
    The code for it is shown below.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
                <pre class="prettyprint C" style="border:none">
void dissplay(){
    if (Month == 0){
       nm = "sunset.bmp"; x = 0; y = 0;
       showBMP();        // Draw the background the first time it is loaded
       nm = "temperat.bmp"; x = 240; y = 10;
       showBMP();    // Draw the thermometer icon
    }
    else{
     logger();
    }

    tft.drawRoundRect(10, 10, 225, 145, 15, RED);    // Draw the box for the clock's display

    tft.drawRoundRect(140, 165, 170, 65, 15,  RED);  // Draw the alarms "box"

    getTime();   // Obtain time from RTC

    // Print the time
    tft.setTextColor(WHITE, CRIMSON);
    tft.setCursor(20, 20);
    tft.setTextSize(6);

    if (TimeMode == "INTL"){
       if (Hour < 10){          // Ensure the hour is presented in two digits regardless of value
         tft.print("0");       // i.e. 1 is displayed as 01
         tft.print(Hour); 
       }
       else{
         tft.print(Hour);
       }

       tft.print(":");

       if (Minute < 10){        // Ensure the minute is presented in two digits regardless of value
         tft.print("0");       // i.e. 1 is displayed as 01
         tft.print(Minute); 
       }
       else{
         tft.print(Minute);
       } 
    }
    else{
       if (Hour < 12 && Hour > 0){
         if (Hour < 10){
           tft.print("0");
           tft.print(Hour);
         }
         else{
           tft.print(Hour);
         }
       }
       else if (Hour == 0){
         tft.print(Hour);
       }
       else{
         if ( (Hour - 12) < 10){
           tft.print("0");
           tft.print(Hour - 12);
         }
         else{
           tft.print(Hour - 12);
         }
       }

       tft.print(":");

       if (Minute < 10){        // Ensure the minute is presented in two digits regardless of value
         tft.print("0");       // i.e. 1 is displayed as 01
         tft.print(Minute); 
       }
       else{
         tft.print(Minute);
       } 
    }

     
    tft.drawRoundRect(240, 10, 70, 145, 15, RED);  //Draw the box for the temperature display
 
    // Print the date, month, year and day
    tft.setCursor(20, 100);                        // Display the time accordingly
    tft.setTextColor(WHITE, CRIMSON);
    tft.setTextSize(2);
    tft.print(Date);
    tft.print(" ");
    tft.print(Months(Month));
    tft.print(", ");
    tft.print(2000 + Year - 48);
    tft.setCursor(20, 130);
    tft.print(days(DoW));   
}
                </pre>       
          </div>
        </div>
    </div>
</div>

<div class="paragraph">
    Firstly, I render the background sunset by changing the value of the variable nm to sunset.bmp, 
    then calling the showBMP() function. Next, I render two rounded, hollow rectangles, one for 
    displaying the current time and the other for displaying the current temperature. At this point, 
    I call on the getTime() function to update the time, and now we can proceed on displaying the time
    and other relevant info. By setting up the appropirate cursor positions and text sizes as shown 
    in the code, we display a large 4 digit clock that can output either in international and imperial 
    time format, the date and the day, along with the current temperature. 
</div>

<div class="headingPadding">
    <div class="heading2">
        The Options Function
    </div>
</div>
<div class="paragraph">
    Much like the dissplay() function, options() exists to render the options layout when the Options variable is 1.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">
void options(){                                    // Options menu
    if (views == 1){
      nm="sunset.bmp"; x = 0; y = 0;
      showBMP();     // Draw the background when first loaded
      views = 0;
    }
    else{
      // Draw the title bar
      tft.setTextColor(WHITE);
      tft.setCursor(20, 20);
      tft.setTextSize(4);
      tft.print("OPTIONS");
      tft.drawLine(10, 53, 310, 53, WHITE);
      tft.setTextSize(2);
      tft.setCursor(20, 65);
      // Display the options (only alarms in this case, more can be added later)
      tft.print("Alarms: ");                         
      tft.drawLine(215, 60, 215, 220, WHITE);
  
      if (alarms == 0){
         // Display the status of the alarms
        tft.setTextColor(RED, BLACK); 
        tft.print("Disabled");
      }
      else{
        tft.setTextColor(GREEN, BLACK);
        tft.print("Enabled ");
      }
  
      tft.setCursor(20, 125);
      tft.setTextColor(WHITE, BLACK);
      tft.print("Mode: ");
      if (TimeMode == "INTL"){
        tft.print("Int'l");
      }
      else{
        tft.print("AM/PM");
      }
  
      tft.setCursor(20, 185);
      tft.setTextColor(WHITE, BLACK);
      tft.print("Logs:");
  
       if (Log == 0){
        
        9  // Display the status of the alarms 
        tft.setTextColor(RED, BLACK);
        tft.print("Disabled");
      }
      else{
        tft.setTextColor(GREEN, BLACK);
        tft.print("Enabled ");
      }
    }
  }
      </pre>
              

          </div>
        </div>
    </div>
</div>

<div class="paragraph">
    Upon calling, it checks if the views variable is 1, and renders the background image to overwrite the previous
    content, and changes the views variable to 0. Now the menu title is displayed on the top left,
    followed by the toggle buttons for the alarm, time format, logging and exiting the menu. It also 
    checks the current state of the variables, and displays their current status on the display.
</div>

<div class="headingPadding">
    <div class="heading2">
        The showBMP Function
    </div>
</div>
<div class="paragraph">
    The showBMP function serves to load and display the background image stored on the SD card, 
    courtesy of prenticedavid’s TFT library. Here’s the code that makes it all happen.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">
uint8_t showBMP()
    {
        File bmpFile;
        int bmpWidth, bmpHeight;    // W+H in pixels
        uint8_t bmpDepth;           // Bit depth (currently must be 24, 16, 8, 4, 1)
        uint32_t bmpImageoffset;    // Start of image data in file
        uint32_t rowSize;           // Not always = bmpWidth; may have padding
        uint8_t sdbuffer[3 * BUFFPIXEL];    // pixel in buffer (R+G+B per pixel)
        uint16_t lcdbuffer[(1 << PALETTEDEPTH) + BUFFPIXEL], *palette = NULL;
        uint8_t bitmask, bitshift;
        boolean flip = true;        // BMP is stored bottom-to-top
        int w, h, row, col, lcdbufsiz = (1 << PALETTEDEPTH) + BUFFPIXEL, buffidx;
        uint32_t pos;               // seek position
        boolean is565 = false;      //
    
        uint16_t bmpID;
        uint16_t n;                 // blocks read
        uint8_t ret;
    
        if ((x >= tft.width()) || (y >= tft.height()))
            return 1;               // off screen
    
        bmpFile = SD.open(nm);      // Parse BMP header
    
        Serial.print(SD.open(nm));
        bmpID = read16(bmpFile);    // BMP signature
        (void) read32(bmpFile);     // Read & ignore file size
        (void) read32(bmpFile);     // Read & ignore creator bytes
        bmpImageoffset = read32(bmpFile);       // Start of image data
        (void) read32(bmpFile);     // Read & ignore DIB header size
        bmpWidth = read32(bmpFile);
        bmpHeight = read32(bmpFile);
        n = read16(bmpFile);        // # planes -- must be '1'
        bmpDepth = read16(bmpFile); // bits per pixel
        pos = read32(bmpFile);      // format
        if (bmpID != 0x4D42) ret = 2; // bad ID
        else if (n != 1) ret = 3;   // too many planes
        else if (pos != 0 && pos != 3) ret = 4; // format: 0 = uncompressed, 3 = 565
        else if (bmpDepth < 16 && bmpDepth > PALETTEDEPTH) ret = 5; // palette 
        else {
            bool first = true;
            is565 = (pos == 3);               // ?already in 16-bit format
            // BMP rows are padded (if needed) to 4-byte boundary
            rowSize = (bmpWidth * bmpDepth / 8 + 3) & ~3;
            if (bmpHeight < 0) {              // If negative, image is in top-down order.
                bmpHeight = -bmpHeight;
                flip = false;
            }
    
            w = bmpWidth;
            h = bmpHeight;
            if ((x + w) >= tft.width())       // Crop area to be loaded
                w = tft.width() - x;
            if ((y + h) >= tft.height())      //
                h = tft.height() - y;
    
            if (bmpDepth <= PALETTEDEPTH) {   // these modes have separate palette
                bmpFile.seek(BMPIMAGEOFFSET); //palette is always @ 54
                bitmask = 0xFF;
                if (bmpDepth < 8)
                    bitmask >>= bmpDepth;
                bitshift = 8 - bmpDepth;
                n = 1 << bmpDepth;
                lcdbufsiz -= n;
                palette = lcdbuffer + lcdbufsiz;
                for (col = 0; col < n; col++) {
                    pos = read32(bmpFile);    //map palette to 5-6-5
                    palette[col] = ((pos & 0x0000F8) >> 3) | ((pos & 0x00FC00) >> 5) | ((pos & 0xF80000) >> 8);
                }
            }
    
            // Set TFT address window to clipped image bounds
            tft.setAddrWindow(x, y, x + w - 1, y + h - 1);
            for (row = 0; row < h; row++) { // For each scanline...
                // Seek to start of scan line.  It might seem labor-
                // intensive to be doing this on every line, but this
                // method covers a lot of gritty details like cropping
                // and scanline padding.  Also, the seek only takes
                // place if the file position actually needs to change
                // (avoids a lot of cluster math in SD library).
                uint8_t r, g, b, *sdptr;
                int lcdidx, lcdleft;
                if (flip)   // Bitmap is stored bottom-to-top order (normal BMP)
                    pos = bmpImageoffset + (bmpHeight - 1 - row) * rowSize;
                else        // Bitmap is stored top-to-bottom
                    pos = bmpImageoffset + row * rowSize;
                if (bmpFile.position() != pos) { // Need seek?
                    bmpFile.seek(pos);
                    buffidx = sizeof(sdbuffer); // Force buffer reload
                }
    
                for (col = 0; col < w; ) {  //pixels in row
                    lcdleft = w - col;
                    if (lcdleft > lcdbufsiz) lcdleft = lcdbufsiz;
                    for (lcdidx = 0; lcdidx < lcdleft; lcdidx++) { // buffer at a time
                        uint16_t color;
                        // Time to read more pixel data?
                        if (buffidx >= sizeof(sdbuffer)) { // Indeed
                            bmpFile.read(sdbuffer, sizeof(sdbuffer));
                            buffidx = 0; // Set index to beginning
                            r = 0;
                        }
                        switch (bmpDepth) {          // Convert pixel from BMP to TFT format
                            case 24:
                                b = sdbuffer[buffidx++];
                                g = sdbuffer[buffidx++];
                                r = sdbuffer[buffidx++];
                                color = tft.color565(r, g, b);
                                break;
                            case 16:
                                b = sdbuffer[buffidx++];
                                r = sdbuffer[buffidx++];
                                if (is565)
                                    color = (r << 8) | (b);
                                else
                                    color = (r << 9) | ((b & 0xE0) << 1) | (b & 0x1F);
                                break;
                            case 1:
                            case 4:
                            case 8:
                                if (r == 0)
                                    b = sdbuffer[buffidx++], r = 8;
                                color = palette[(b >> bitshift) & bitmask];
                                r -= bmpDepth;
                                b <<= bmpDepth;
                                break;
                        }
                        lcdbuffer[lcdidx] = color;
    
                    }
                    tft.pushColors(lcdbuffer, lcdidx, first);
                    first = false;
                    col += lcdidx;
                }           // end cols
            }               // end rows
            tft.setAddrWindow(0, 0, tft.width() - 1, tft.height() - 1); //restore full screen
            ret = 0;        // good render
        }
        bmpFile.close();
        return (ret);
    }
            </pre>                

          </div>
        </div>
    </div>
</div>

<div class="headingPadding">
    <div class="heading2">
        The Logger Function
    </div>
</div>
<div class="paragraph">
    The logger() function serves to write the current temperature data to a CSV file in the templogs 
    folder, with each file being named on the date of its creation. The code is as follows.
</div>

<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C" style="border:none">
void logger(){
    if (Log == 1){
        File logData;
        String folderName = "templogs/";
        String fileName = String(Date) + "-" + String(Month) + "-" + "20" + String(Year - 48) + ".csv";
        String line = String(Hour) + ":" + String(Minute) + "," + String(temp) + "\r\n";
      
        logData = SD.open(folderName + fileName, FILE_WRITE);
    
        if ( (Hour * 100 + Minute) ==  0){
          logData.print(F("Time of Day, Temperature\r\n"));
          logData.print(line);
        }
        else{
          logData.print(line); 
        }
    
        logData.close();
      }
    }
            </pre>
          </div>
        </div>
    </div>
</div>

<div class="paragraph">
    First, it creates a file called logData as a buffer to hold the data temporarily. 
    Then it assigns a filename to the SD card, and opens it in write mode, and prints the 
    headings for the file if it has just been created, followd by the values of the time of 
    day and the temperature. Once that is done, it closes the file to save the changes.
</div>

<div class="headingPadding">
    <div class="heading2">
        The initOptions Function
    </div>
</div>
<div class="paragraph">
    The initOptions() function initializes the buttons to be displayed on the display. 
    To prevent it from repeatedly rendering the buttons and cause flickering, a ButtonsInit variable 
    is used to ensure the buttons are rendered once. If the value of Options is 1, it renders 
    the alarm off and on buttons, the International and Imperial layout buttons and the logging off 
    and on buttons. If the value of Options is 0, it renders the option button to switch to options 
    in a similar fashion. Finally, if the ring variable equals to 1, it renders the button to stop 
    the alarm.
</div>
<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C">
void initOptions(){     // Initialization for the buttons
    if (ButtonsInit == 0 && Options == 1){
      alarm_btn.initButton(     &tft, 270, 70, 50, 20, WHITE, WHITE, BLACK, "ON", 2);
      alarm_off_btn.initButton( &tft, 270, 95, 50, 20, WHITE, WHITE, BLACK, "OFF", 2);
      International.initButton( &tft, 270, 130, 50, 20, WHITE, WHITE, BLACK, "INTL", 2);
      Imperial.initButton(      &tft, 270, 155, 50, 20, WHITE, WHITE, BLACK, "IMP", 2);
      log_on.initButton(        &tft, 270, 190, 50, 20, WHITE, WHITE, BLACK, "ON", 2);
      log_off.initButton(       &tft, 270, 215, 50, 20, WHITE, WHITE, BLACK, "OFF", 2);
      
      close_btn.initButton(&tft, 270, 35, 60, 25, RED, RED, WHITE, "Exit", 2);
      
      alarm_btn.drawButton(false);
      alarm_off_btn.drawButton(false);
      International.drawButton(false);
      Imperial.drawButton(false);
      log_on.drawButton(false);
      log_off.drawButton(false);
      
      close_btn.drawButton(false);
      ButtonsInit = 1;
    }
    if (ButtonsInit == 0 && Options == 0){
      option_btn.initButton(&tft,  60, 200, 100, 40, WHITE, YELLOW, BLACK, "Options", 2);
      option_btn.drawButton(false);
      ButtonsInit = 1;
    }
    if (ring == 1){
        alarm_stop.initButton(&tft,  225, 198, 170, 65, RED, RED, WHITE, "STOP", 3);
        alarm_stop.drawButton(false);
    }
  }
</pre>
          </div>
        </div>
    </div>
</div>

<div class="headingPadding">
    <div class="heading2">
        The Touch_getXY Function
    </div>
</div>
<div class="paragraph">
    The Touch_getXY() function returns coordinates when the touch panel is pressed.
</div>
<div class="accordion" id="accordionExample" style="padding-left: 20px; padding-right:20px">
    <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne" style="background-color: darkgray;">
            Expand code
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse hidden" aria-labelledby="headingOne" data-bs-parent="#accordionExample" style="background-color: gray;">
          <div class="accordion-body">
            <pre class="prettyprint C">

            bool Touch_getXY(void)
            {
                TSPoint p = ts.getPoint();
                pinMode(YP, OUTPUT);      // Set up the power lines for the resistive touch panel
                pinMode(XM, OUTPUT);
                digitalWrite(YP, HIGH);   // Provide power to the aforementioned panel
                digitalWrite(XM, HIGH);
                
                bool pressed = (p.z > MINPRESSURE && p.z < MAXPRESSURE);  // Figure out the position of the touch position
                if (pressed) 
                {
                    pixel_x =  round((float(p.y) / float(742)) * 320) ;
                    pixel_x = round( (float(pixel_x - 55)/float(321))*320 );  // TOTALLY ACCURATE KOMRAD
                    pixel_y =  round((float(855-p.x)/float(707)) * 240);    // STALIN APPROVE CYKA
                }
            
                return pressed;
            }
        </pre>
          </div>
        </div>
    </div>
</div>

<div class="headingPadding">
    <div class="heading">
        Personal Note
    </div>
</div>
<div class="paragraph">
    If you've read through the content, thank you for chiming in! ^.^ Please do leave a comment down below 
    for any suggestions on where I could improve!
</div>
{% endblock %}